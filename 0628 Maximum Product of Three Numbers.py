'''排序后数组可以分为三种情况：
1. 都为正数：最后三个数相乘
2. 都为负数：最后三个数相乘
3. 有正有负
（1）只有一个负数：最后三个数相乘
（2）有两个及以上的负数：前两个负数与数组最后一个正数相乘，或最后三个数相乘

归纳：max（排序数组最后三个数相乘，排序数组前两个负数与数组最后一个正数相乘）'''

def maximumProduct(nums):
    """排序方法，时间复杂度O(nlog(n))"""
    # nums.sort()
    # return max(nums[-1] * nums[-2] * nums[-3], nums[-1] * nums[0] * nums[1])

    """遍历一遍数组，不使用排序，时间复杂度O(n)"""
    max1 = -float('inf')       # 第一大的值
    max2 = -float('inf')       # 第二大的值
    max3 = -float('inf')       # 第三大的值
    min1 = float('inf')        # 第一小的值
    min2 = float('inf')        # 第二小的值

    for num in nums:
        if num > max1:         # 啥？你比第一大的值还大？？那好吧，你去做老大
            max3 = max2        # 原老二委屈一下你，去做老三吧，难受...
            max2 = max1        # 原老大委屈一下你，去做老二吧，很难受...
            max1 = num         # 大哥快请上座！！！
        elif num > max2:       # 嗯？你比第二大的值大啊？？那行吧，老二给你做，别碰老大啊，他脾气不好...
            max3 = max2        # 原老二委屈一下你，去做老三吧，难受...
            max2 = num         # 二哥请上座！！
        elif num > max3:       # 别舞舞喳喳的，不就比第三大的值大么？？去去去，那个位置给你了...
            max3 = num         # 三哥上座！
        
        if num < min1:         # 啊？你比第一小的值还小，哈哈哈，笑死我了，来来来，快去！
            min2 = min1        # 原第一小，恭喜你，终于找到比你小的了，你现在是第二小！
            min1 = num         # 老实呆着，你现在是最小的了！！！
        elif num < min2:       # 哦？你比第二小的值小？比最小的还大，嗯..那你去做第二小
            min2 = num         # 来吧，你现在是第二小，原第二小解脱了！
        
    return max(max1 * max2 * max3, max1 * min1 * min2)

print(maximumProduct([722,634,-504,-379,163,-613,-842,-578,750,951,-158,30,-238,-392,-487,-797,-157,-374,999,-5,-521,-879,-858,382,626,803,-347,903,-205,57,-342,186,-736,17,83,726,-960,343,-984,937,-758,-122,577,-595,-544,-559,903,-183,192,825,368,-674,57,-959,884,29,-681,-339,582,969,-95,-455,-275,205,-548,79,258,35,233,203,20,-936,878,-868,-458,-882,867,-664,-892,-687,322,844,-745,447,-909,-586,69,-88,88,445,-553,-666,130,-640,-918,-7,-420,-368,250,-786]))